<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Security</title>
  <link href="../Styles/stylesheet.css" rel="stylesheet" type="text/css" />
  <script src="../toc.js" type="text/javascript">



  //<![CDATA[

   <!-- empty -->
  //]]>
  </script>
  <script type="text/javascript">




  /* <![CDATA[ */
    (function() {
        var s = document.createElement("script"), t = document.getElementsByTagName("script")[0];
        s.type = "text/javascript";
        s.async = true;
        s.src = "http://api.flattr.com/js/0.6/load.js?mode=auto";
        t.parentNode.insertBefore(s, t);
    })();
  /* ]]> */
  </script>
  <style type="text/css">
/*<![CDATA[*/

  body { counter-reset: chapter 7; }

  a.sgc-8 {display:none;}
  span.sgc-7 {color: darkmagenta}
  span.sgc-6 {color: black}
  span.sgc-5 {color: green}
  span.sgc-4 {color: blue}
  span.sgc-3 {color: DarkRed}
  span.sgc-2 {color: purple}
  span.sgc-1 {color: firebrick}
  /*]]>*/
  </style>
</head>

<body>
  <div class="chapter">
    <h1 class="en"> Security </h1>
    <h1 class="zh"> 安全 </h1>
  </div>

  <div class="preface"></div>

  <div class="generate_from_h2" id="generated-toc"></div>

  <h2 id="heading_toc_j_0" tabindex="-1" class="en">Introduction</h2>
  <h2 id="heading_toc_j_0" tabindex="-1"  class="zh">简介</h2>

<p class="en">
  Although the internet was originally designed as a system to withstand
  atacks by hostile agents, it developed in a co-operative environment
  of relatively trusted entities. Alas, those days are long gone.
  Spam mail, denial of service attacks, phishing attempts and so on
  are indicative that anyone using the internet does so at their own
  risk.
</p>
<p class="zh">
在合作开发比较可信的环境中,最初的互联网被设计成一个安全的且能抵御敌对代理攻击的系统。
可惜，那些日子已经一去不复返了。网民自行承担垃圾邮件，拒绝服务攻击，网络钓鱼等攻击风险。
</p>
<p class="en">
  Applications have to be built to work correctly in
  hostile situations. "correctly" no longer means just getting
  the functional aspects of the program correct, but also means
  ensuring privacy and integrity of data transferred, access
  only to legitimate users and other issues.
</p>
<p class="zh">
应用程序在复杂的互联网环境中应能正确工作.“正确”不再意味着在程序调用的正确，而是在应用中确保数据传输的保密性和完整性，合法访问等问题。
</p>
<p class="en">
  This of course makes your programs much more complex. There are
  <em>difficult</em> and <em>subtle</em> computing problems involved 
  in making applications secure. Attempts to do it yourself (such as
  making up your own encryption libraries) are usually doomed
  to failure. Instead, you need to make use of libraries designed
  by security professionals
</p>
<p class="zh">
这一节编程会很复杂,在构建安全的应用程序的过程中将会出现很复杂和微妙的问题.如果你企图这样做(自己实现一个安全库)最后通常是失败.但是我们可以使用安全专家实现好的安全库.
</p>
<h2 id="heading_toc_j_1" tabindex="-1" class="en"> ISO security architecture </h2>
<h2 id="heading_toc_j_1" tabindex="-1" class="zh"> ISO 安全架构 </h2>
<p class="en">
  The ISO OSI (open systems interconnect) seven-layer model of
  distributed systems is well known and is repeated in this
  figure: <br>
  <img src="./Security_files/iso.gif">
</p>
<p class="zh">
ISO OSI（开放系统互连）七层模型分布式系统是众所周知的，在此重复图<br>
  <img src="./Security_files/iso.gif">
</p>
<p class="en">
  What is less well known is that ISO built a whole series of
  documents upon this architecture. For our purposes here, the most
  important is the ISO Security Architecture model, ISO 7498-2.
</p>
<p class="zh">
少为人知的国际标准化组织建立了一个全系列的这种架构文档。在这里，最重要的是，ISO安全体系结构模型
</p>
<h3 id="heading_toc_j_2" tabindex="-1" class="en"> Functions and levels </h3>
<h3 id="heading_toc_j_2" tabindex="-1" class="zh"> 功能层次 </h3>

<p class="en">
  The principal functions required of a security system are
</p>
<p class="zh">
主要的安全系统功能
</p>
<ul class="en">
<li>
  Authentication - proof of identity
</li>
<li>
  Data integrity  - data is not tampered with
</li>
<li>
  Confidentiality - data is not exposed to others
</li>
<li>
  Notarization/signature
</li>
<li>
  Access control
</li>
<li>
  Assurance/availability
</li>
</ul>
<ul class="zh">
<li>
  认证 - 身份校验文件
</li>
<li>
  数据完整性 - 数据不被篡改
</li>
<li>
  保密 - 数据不能暴露给他人
</li>
<li>
  公证/签名
</li>
<li>
  访问控制
</li>
<li>
  保证/可用性
</li>
</ul>
<p></p>

<p class="en">
  These are required at the following levels of the OSI stack:
</p>
<p class="zh">
  必须的OSI协议栈
</p>
<ul class="en">
    <li>
      Peer entity authentication (3, 4, 7)
    </li>
    <li>
      Data origin authentication (3, 4, 7)
    </li>
    <li>
      Access control service (3, 4, 7)
    </li>
    <li>
      Connection confidentiality (1, 2, 3, 4, 6, 7)
    </li>
    <li>
      Connectionless confidentiality (1, 2, 3, 4, 6, 7)
    </li>
    <li>
      Selective field confidentiality (6, 7)
    </li>
    <li>
      Traffic flow confidentiality (1, 3, 7)
    </li>
    <li>
      Connection integrity with recovery (4, 7)
    </li>
    <li>
      Connection integrity without recovery (4, 7)
    </li>
    <li>
      Connection integrity selective field (7)
    </li>
    <li>
      Connectionless integrity selective field (7)
    </li>
    <li>
      Non-repudiation at origin (7)
    </li>
    <li>
      Non-repudiation of receipt (7)
    </li>
 </ul>
 <ul class="zh">
    <li>
      对等实体认证 (3, 4, 7)
    </li>
    <li>
      数据源认证 (3, 4, 7)
    </li>
    <li>
      访问控制服务 (3, 4, 7)
    </li>
    <li>
      连接保密 (1, 2, 3, 4, 6, 7)
    </li>
    <li>
      无连接的保密 (1, 2, 3, 4, 6, 7)
    </li>
    <li>
      选择性字段的保密 (6, 7)
    </li>
    <li>
      传输保密 (1, 3, 7)
    </li>
    <li>
      恢复连接的完整性 (4, 7)
    </li>
    <li>
      不可恢复连接的完整性 (4, 7)
    </li>
    <li>
      选择字段连接完整性 (7)
    </li>
    <li>
      选择字段的无连接完整性 (7)
    </li>
    <li>
      接受源 (7)
    </li>
    <li>
      接受回执 (7)
    </li>
 </ul>
<p></p>  
<!--
<h3> PEM </h3>
<p>

  <code>
    <pre>
var pemPrivateKey = `=====BEGIN RSA PRIVATE KEY=====
MIIBOgIBAAJBALKZD0nEffqM1ACuak0bijtqE2QrI/KLADv7l3kK3ppMyCuLKoF0
fd7Ai2KW5ToIwzFofvJcS/STa6HA5gQenRUCAwEAAQJBAIq9amn00aS0h/CrjXqu
/ThglAXJmZhOMPVn4eiu7/ROixi9sex436MaVeMqSNf7Ex9a8fRNfWss7Sqd9eWu
RTUCIQDasvGASLqmjeffBNLTXV2A5g4t+kLVCpsEIZAycV5GswIhANEPLmax0ME/
EO+ZJ79TJKN5yiGBRsv5yvx5UiHxajEXAiAhAol5N4EUyq6I9w1rYdhPMGpLfk7A
IU2snfRJ6Nq2CQIgFrPsWRCkV+gOYcajD17rEqmuLrdIRexpg8N1DOSXoJ8CIGlS
tAboUGBxTDq3ZroNism3DaMIbKPyYrAqhKov1h5V
=====END RSA PRIVATE KEY=====
`

func bigFromString(s string) *big.Int {
        ret := new(big.Int)
        ret.SetString(s, 10)
        return ret
}

var rsaPrivateKey = &rsa.PrivateKey{
        PublicKey: rsa.PublicKey{
                N: bigFromString("9353930466774385905609975137998169297361893554
14998671685329502257853572497967725295852446635047121036783518748074826886427746
4700638583474144061408845077"),
                E: 65537,
        },
        D: bigFromString("726639843132811634405769937974922253227934392381906363
94970490393898993285385430876577337665541558398345195294398516730148002612857577
59040931985506583861"),
        P: bigFromString("989203665480846436017288690555926508355729509322669674
61790948584315647051443"),
        Q: bigFromString("945602083088470157474985238840633946716066719049446663
60068158221458669711639"),
}

        block, _ := pem.Decode([]byte(pemPrivateKey))
        priv, err := ParsePKCS1PrivateKey(block.Bytes)
    </pre>
  </code>
</p>
-->

  <h2 id="heading_toc_j_7" tabindex="-1" class="en"> X.509 certificates </h2>
<h2 id="heading_toc_j_7" tabindex="-1" class="zh"> X.509 证书 </h2>
<p class="en">
  A Public Key Infrastructure (PKI) is a framework for a collection
  of public keys, along with additional information such as 
  owner name and location, and links between them giving some
  sort of approval mechanism.
</p>
<p class="zh">
公钥基础设施（PKI）是一个公钥集合框架.连同附加信息,如所有者名称和位置,以及它们之间的联系提供了一些排序的审批机制。
</p>
<p class="en">
  The principal PKI in use today is based on X.509 certificates.
  For example, web browsers use them to verify the identity
  of web sites.
</p>
<p class="zh">
当下主要使用的PKI是基于X.509证书的.例如浏览器使用它验证站点.
</p>
<p class="en">
  An example program to generate a self-signed X.509 certificate
  for my web site and store it in a <code>.cer</code> file is
</p>
<p class="zh">
下面是为自己的站点生成自签名X.509证书并存储在<code>.cer</code>文件中的一个程序
</p>
<pre><code><font color="black">
<font color="firebrick">/* GenX509Cert
 */
</font>
<font color="purple">package</font> main

<font color="purple">import</font> (
  <font color="DarkRed">"crypto/rand"</font>
	<font color="DarkRed">"crypto/rsa"</font>
	<font color="DarkRed">"crypto/x509"</font>
	<font color="DarkRed">"crypto/x509/pkix"</font>
	<font color="DarkRed">"encoding/gob"</font>
	<font color="DarkRed">"encoding/pem"</font>
	<font color="DarkRed">"fmt"</font>
	<font color="DarkRed">"math/big"</font>
	<font color="DarkRed">"os"</font>
	<font color="DarkRed">"time"</font>
)

<font color="purple">func</font> main() {
	random := rand.<font color="blue">Reader</font>

	<font color="purple">var</font> key rsa.<font color="blue">PrivateKey</font>
	loadKey(<font color="DarkRed">"private.key"</font>, &amp;key)

	now := time.<font color="blue">Now</font>()
	then := now.<font color="blue">Add</font>(60 * 60 * 24 * 365 * 1000 * 1000 * 1000) <font color="firebrick">// one year
</font>	template := x509.<font color="blue">Certificate</font>{
		<font color="blue">SerialNumber</font>: big.<font color="blue">NewInt</font>(1),
		<font color="blue">Subject</font>: pkix.<font color="blue">Name</font>{
			<font color="blue">CommonName</font>:   <font color="DarkRed">"jan.newmarch.name"</font>,
			<font color="blue">Organization</font>: []string{<font color="DarkRed">"Jan Newmarch"</font>},
		},
		<font color="firebrick">//	NotBefore: time.Unix(now, 0).UTC(),
</font>		<font color="firebrick">//	NotAfter:  time.Unix(now+60*60*24*365, 0).UTC(),
</font>		<font color="blue">NotBefore</font>: now,
		<font color="blue">NotAfter</font>:  then,

		<font color="blue">SubjectKeyId</font>: []<font color="green">byte</font>{1, 2, 3, 4},
		<font color="blue">KeyUsage</font>:     x509.<font color="blue">KeyUsageCertSign</font> | x509.<font color="blue">KeyUsageKeyEncipherment</font> | x509.<font color="blue">KeyUsageDigitalSignature</font>,

		<font color="blue">BasicConstraintsValid</font>: true,
		<font color="blue">IsCA</font>:                  true,
		<font color="blue">DNSNames</font>:              []string{<font color="DarkRed">"jan.newmarch.name"</font>, <font color="DarkRed">"localhost"</font>},
	}
	derBytes, err := x509.<font color="blue">CreateCertificate</font>(random, &amp;template,
		&amp;template, &amp;key.<font color="blue">PublicKey</font>, &amp;key)
	checkError(err)

	certCerFile, err := os.<font color="blue">Create</font>(<font color="DarkRed">"jan.newmarch.name.cer"</font>)
	checkError(err)
	certCerFile.<font color="blue">Write</font>(derBytes)
	certCerFile.<font color="blue">Close</font>()

	certPEMFile, err := os.<font color="blue">Create</font>(<font color="DarkRed">"jan.newmarch.name.pem"</font>)
	checkError(err)
	pem.<font color="blue">Encode</font>(certPEMFile, &amp;pem.<font color="blue">Block</font>{<font color="blue">Type</font>: <font color="DarkRed">"CERTIFICATE"</font>, <font color="blue">Bytes</font>: derBytes})
	certPEMFile.<font color="blue">Close</font>()

	keyPEMFile, err := os.<font color="blue">Create</font>(<font color="DarkRed">"private.pem"</font>)
	checkError(err)
	pem.<font color="blue">Encode</font>(keyPEMFile, &amp;pem.<font color="blue">Block</font>{<font color="blue">Type</font>: <font color="DarkRed">"RSA PRIVATE KEY"</font>,
		<font color="blue">Bytes</font>: x509.<font color="blue">MarshalPKCS1PrivateKey</font>(&amp;key)})
	keyPEMFile.<font color="blue">Close</font>()
}

<font color="purple">func</font> loadKey(fileName string, key <font color="purple">interface</font>{}) {
	inFile, err := os.<font color="blue">Open</font>(fileName)
	checkError(err)
	decoder := gob.<font color="blue">NewDecoder</font>(inFile)
	err = decoder.<font color="blue">Decode</font>(key)
	checkError(err)
	inFile.<font color="blue">Close</font>()
}

<font color="purple">func</font> checkError(err error) {
	<font color="purple">if</font> err != nil {
		fmt.<font color="blue">Println</font>(<font color="DarkRed">"Fatal error "</font>, err.<font color="blue">Error</font>())
		os.<font color="blue">Exit</font>(1)
	}
}
</font></code></pre>

<p></p>

<p class="en">
  This can then be read back in by
</p>
<p class="zh">
下面这个程序可以获取这个证书
</p>
<pre><code><font color="black">
<font color="firebrick">/* GenX509Cert
 */
</font>
<font color="purple">package</font> main

<font color="purple">import</font> (
	<font color="DarkRed">"crypto/x509"</font>
	<font color="DarkRed">"fmt"</font>
	<font color="DarkRed">"os"</font>
)

<font color="purple">func</font> main() {
	certCerFile, err := os.<font color="blue">Open</font>(<font color="DarkRed">"jan.newmarch.name.cer"</font>)
	checkError(err)
	derBytes := make([]<font color="green">byte</font>, 1000) <font color="firebrick">// bigger than the file
</font>	count, err := certCerFile.<font color="blue">Read</font>(derBytes)
	checkError(err)
	certCerFile.<font color="blue">Close</font>()

	<font color="firebrick">// trim the bytes to actual length in call
</font>	cert, err := x509.<font color="blue">ParseCertificate</font>(derBytes[0:count])
	checkError(err)

	fmt.<font color="blue">Printf</font>(<font color="DarkRed">"Name %s\n"</font>, cert.<font color="blue">Subject</font>.<font color="blue">CommonName</font>)
	fmt.<font color="blue">Printf</font>(<font color="DarkRed">"Not before %s\n"</font>, cert.<font color="blue">NotBefore</font>.<font color="blue">String</font>())
	fmt.<font color="blue">Printf</font>(<font color="DarkRed">"Not after %s\n"</font>, cert.<font color="blue">NotAfter</font>.<font color="blue">String</font>())

}

<font color="purple">func</font> checkError(err error) {
	<font color="purple">if</font> err != nil {
		fmt.<font color="blue">Println</font>(<font color="DarkRed">"Fatal error "</font>, err.<font color="blue">Error</font>())
		os.<font color="blue">Exit</font>(1)
	}
}
</font></code></pre>

<p></p>

<h2 id="heading_toc_j_8" tabindex="-1" class="en"> TLS </h2>
<h2 id="heading_toc_j_8" tabindex="-1" class="zh"> 安全传输层 </h2>
<p class="en">
Encryption/decryption schemes are of limited use if you have to do
all the heavy lifting yourself. The most popular mechanism on the internet
to give support for encrypted message passing is currently TLS
(Transport Layer Security) which was formerly SSL 
(Secure Sockets Layer).
</p>
<p class="zh">
你自己实现的加密和解密方案的使用是有限制的.在互联网上最流行的机制支持加密的消息传递给目前TLS（安全传输层），其前身为SSL（安全套接字层）。
</p>
<p class="en">
In TLS, a client and a server negotiate identity using X.509 certificates.
One this is complete, a secret key is invented between them, and all
encryption/decryption is done using this key. The negotiation is
relatively slow, but once complete a faster private key mechanism is used.
</p>
<p class="zh"></p>
在TLS中，客户端和服务器之间使用X.509证书验证身份.身份验证完成后,在两者之间产生一个密钥,所有的加密和解密过程都使用这个密钥.这个过程虽然很慢,但是一旦完成你将使用一个非常快的私钥机制
<p class="en">
  A server is 
</p>
<p class="zh">
服务器端程序
</p>
<pre><code><font color="black">
<font color="firebrick">/* TLSEchoServer
 */
</font><font color="purple">package</font> main

<font color="purple">import</font> (
	<font color="DarkRed">"crypto/rand"</font>
	<font color="DarkRed">"crypto/tls"</font>
	<font color="DarkRed">"fmt"</font>
	<font color="DarkRed">"net"</font>
	<font color="DarkRed">"os"</font>
	<font color="DarkRed">"time"</font>
)

<font color="purple">func</font> main() {

	cert, err := tls.<font color="blue">LoadX509KeyPair</font>(<font color="DarkRed">"jan.newmarch.name.pem"</font>, <font color="DarkRed">"private.pem"</font>)
	checkError(err)
	config := tls.<font color="blue">Config</font>{<font color="blue">Certificates</font>: []tls.<font color="blue">Certificate</font>{cert}}

	now := time.<font color="blue">Now</font>()
	config.<font color="blue">Time</font> = <font color="purple">func</font>() time.<font color="blue">Time</font> { <font color="purple">return</font> now }
	config.<font color="blue">Rand</font> = rand.<font color="blue">Reader</font>

	service := <font color="DarkRed">"0.0.0.0:1200"</font>

	listener, err := tls.<font color="blue">Listen</font>(<font color="DarkRed">"tcp"</font>, service, &amp;config)
	checkError(err)
	fmt.<font color="blue">Println</font>(<font color="DarkRed">"Listening"</font>)
	<font color="purple">for</font> {
		conn, err := listener.<font color="blue">Accept</font>()
		<font color="purple">if</font> err != nil {
			fmt.<font color="blue">Println</font>(err.<font color="blue">Error</font>())
			<font color="purple">continue</font>
		}
		fmt.<font color="blue">Println</font>(<font color="DarkRed">"Accepted"</font>)
		go handleClient(conn)
	}
}

<font color="purple">func</font> handleClient(conn net.<font color="blue">Conn</font>) {
	defer conn.<font color="blue">Close</font>()

	<font color="purple">var</font> buf [512]<font color="green">byte</font>
	<font color="purple">for</font> {
		fmt.<font color="blue">Println</font>(<font color="DarkRed">"Trying to read"</font>)
		n, err := conn.<font color="blue">Read</font>(buf[0:])
		<font color="purple">if</font> err != nil {
			fmt.<font color="blue">Println</font>(err)
		}
		<font color="darkmagenta">_</font>, err2 := conn.<font color="blue">Write</font>(buf[0:n])
		<font color="purple">if</font> err2 != nil {
			<font color="purple">return</font>
		}
	}
}

<font color="purple">func</font> checkError(err error) {
	<font color="purple">if</font> err != nil {
		fmt.<font color="blue">Println</font>(<font color="DarkRed">"Fatal error "</font>, err.<font color="blue">Error</font>())
		os.<font color="blue">Exit</font>(1)
	}
}
</font></code></pre>

<p></p>

<p class="en">
  The server works  with the following client: 
</p>
<p class="zh">
与服务器端程序对应的客户端程序:
</p>
<pre><code><font color="black">
<font color="firebrick">/* TLSEchoClient
 */
</font><font color="purple">package</font> main

<font color="purple">import</font> (
	<font color="DarkRed">"fmt"</font>
	<font color="DarkRed">"os"</font>
	<font color="DarkRed">"crypto/tls"</font>
)

<font color="purple">func</font> main() {
	<font color="purple">if</font> len(os.<font color="blue">Args</font>) != 2 {
		fmt.<font color="blue">Println</font>(<font color="DarkRed">"Usage: "</font>, os.<font color="blue">Args</font>[0], <font color="DarkRed">"host:port"</font>)
		os.<font color="blue">Exit</font>(1)
	}
	service := os.<font color="blue">Args</font>[1]

	conn, err := tls.<font color="blue">Dial</font>(<font color="DarkRed">"tcp"</font>, service, nil)
	checkError(err)

	<font color="purple">for</font> n := 0; n &lt; 10; n++ {
		fmt.<font color="blue">Println</font>(<font color="DarkRed">"Writing..."</font>)
		conn.<font color="blue">Write</font>([]<font color="green">byte</font>(<font color="DarkRed">"Hello "</font> + string(n+48)))

		<font color="purple">var</font> buf [512]<font color="green">byte</font>
		n, err := conn.<font color="blue">Read</font>(buf[0:])
		checkError(err)

		fmt.<font color="blue">Println</font>(string(buf[0:n]))
	}
	os.<font color="blue">Exit</font>(0)
}

<font color="purple">func</font> checkError(err error) {
	<font color="purple">if</font> err != nil {
		fmt.<font color="blue">Println</font>(<font color="DarkRed">"Fatal error "</font>, err.<font color="blue">Error</font>())
		os.<font color="blue">Exit</font>(1)
	}
}
</font></code></pre>

<p></p>

<h2 id="heading_toc_j_9" tabindex="-1" class="en"> Conclusion </h2>
<h2 id="heading_toc_j_9" tabindex="-1" class="zh"> 结论 </h2>
<p class="en">
Security is a huge area in itself, and in this chapter we have barely touched on it.
However, the major concepts have been covered. What has not been stressed is how
much security needs to be built into the design phase: security as an afterthought
is nearly always a failure.
</p>
<p class="zh">
安全本身是一个巨大的领域，在本章中，我们几乎没有触及。然而，主要的概念已覆盖.没有强调的是怎样将安全构建与设计之中:之后的安全总是失败的.
</p>
  <p>Copyright Jan Newmarch, jan@newmarch.name</p>

  <p>If you like this book, please contribute using Flattr <a class="FlattrButton sgc-8" href="http://jan.newmarch.name/go/index.html"></a><br />
  or donate using PayPal</p>

  <form action="https://www.paypal.com/cgi-bin/webscr" method="post">
    <input name="cmd" type="hidden" value="_s-xclick" /> <input name="encrypted" type="hidden" value="-----BEGIN PKCS7-----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-----END PKCS7----- " /> <input alt="PayPal - The safer, easier way to pay online." border="0" name="submit" src="https://www.paypalobjects.com/WEBSCR-640-20110401-1/en_AU/i/btn/btn_donateCC_LG.gif" type="image" /> <img alt="" border="0" height="1" src="https://www.paypalobjects.com/WEBSCR-640-20110401-1/en_AU/i/scr/pixel.gif" width="1" />
  </form>
</body>
</html>
